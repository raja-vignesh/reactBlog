{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firestoreRef = firestoreRef;\nexports.getQueryName = getQueryName;\nexports.getBaseQueryName = getBaseQueryName;\nexports.listenerExists = listenerExists;\nexports.attachListener = attachListener;\nexports.detachListener = detachListener;\nexports.queryStrToObj = queryStrToObj;\nexports.getQueryConfig = getQueryConfig;\nexports.getQueryConfigs = getQueryConfigs;\nexports.orderedFromSnap = orderedFromSnap;\nexports.dataByIdSnapshot = dataByIdSnapshot;\nexports.getPopulateChild = getPopulateChild;\nexports.populateList = populateList;\nexports.promisesForPopulate = promisesForPopulate;\nexports.dispatchListenerResponse = dispatchListenerResponse;\nexports.getPopulateActions = getPopulateActions;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _some2 = _interopRequireDefault(require(\"lodash/some\"));\n\nvar _set2 = _interopRequireDefault(require(\"lodash/set\"));\n\nvar _get2 = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _map2 = _interopRequireDefault(require(\"lodash/map\"));\n\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _forEach2 = _interopRequireDefault(require(\"lodash/forEach\"));\n\nvar _trim2 = _interopRequireDefault(require(\"lodash/trim\"));\n\nvar _size2 = _interopRequireDefault(require(\"lodash/size\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _isFunction2 = _interopRequireDefault(require(\"lodash/isFunction\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _isString2 = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _async = require(\"../utils/async\");\n\nvar _constants = require(\"../constants\");\n\nfunction addWhereToRef(ref, where) {\n  if (!(0, _isArray2.default)(where)) {\n    throw new Error('where parameter must be an array.');\n  }\n\n  if ((0, _isString2.default)(where[0])) {\n    return where.length > 1 ? ref.where.apply(ref, (0, _toConsumableArray2.default)(where)) : ref.where(where[0]);\n  }\n\n  return where.reduce(function (acc, whereArgs) {\n    return addWhereToRef(acc, whereArgs);\n  }, ref);\n}\n\nfunction addOrderByToRef(ref, orderBy) {\n  if (!(0, _isArray2.default)(orderBy) && !(0, _isString2.default)(orderBy)) {\n    throw new Error('orderBy parameter must be an array or string.');\n  }\n\n  if ((0, _isString2.default)(orderBy)) {\n    return ref.orderBy(orderBy);\n  }\n\n  if ((0, _isString2.default)(orderBy[0])) {\n    return ref.orderBy.apply(ref, (0, _toConsumableArray2.default)(orderBy));\n  }\n\n  return orderBy.reduce(function (acc, orderByArgs) {\n    return addOrderByToRef(acc, orderByArgs);\n  }, ref);\n}\n\nfunction handleSubcollections(ref, subcollectionList) {\n  if (subcollectionList) {\n    (0, _forEach2.default)(subcollectionList, function (subcollection) {\n      if (subcollection.collection) {\n        if (!(0, _isFunction2.default)(ref.collection)) {\n          throw new Error(\"Collection can only be run on a document. Check that query config for subcollection: \\\"\".concat(subcollection.collection, \"\\\" contains a doc parameter.\"));\n        }\n\n        ref = ref.collection(subcollection.collection);\n      }\n\n      if (subcollection.doc) ref = ref.doc(subcollection.doc);\n      if (subcollection.where) ref = addWhereToRef(ref, subcollection.where);\n\n      if (subcollection.orderBy) {\n        ref = addOrderByToRef(ref, subcollection.orderBy);\n      }\n\n      if (subcollection.limit) ref = ref.limit(subcollection.limit);\n      if (subcollection.startAt) ref = ref.startAt(subcollection.startAt);\n\n      if (subcollection.startAfter) {\n        ref = ref.startAfter(subcollection.startAfter);\n      }\n\n      if (subcollection.endAt) ref = ref.endAt(subcollection.endAt);\n      if (subcollection.endBefore) ref = ref.endBefore(subcollection.endBefore);\n      ref = handleSubcollections(ref, subcollection.subcollections);\n    });\n  }\n\n  return ref;\n}\n\nfunction firestoreRef(firebase, meta) {\n  if (!firebase.firestore) {\n    throw new Error('Firestore must be required and initalized.');\n  }\n\n  var collection = meta.collection,\n      doc = meta.doc,\n      subcollections = meta.subcollections,\n      where = meta.where,\n      orderBy = meta.orderBy,\n      limit = meta.limit,\n      startAt = meta.startAt,\n      startAfter = meta.startAfter,\n      endAt = meta.endAt,\n      endBefore = meta.endBefore;\n  var ref = firebase.firestore().collection(collection);\n  if (doc) ref = ref.doc(doc);\n  ref = handleSubcollections(ref, subcollections);\n  if (where) ref = addWhereToRef(ref, where);\n  if (orderBy) ref = addOrderByToRef(ref, orderBy);\n  if (limit) ref = ref.limit(limit);\n  if (startAt) ref = ref.startAt(startAt);\n  if (startAfter) ref = ref.startAfter(startAfter);\n  if (endAt) ref = ref.endAt(endAt);\n  if (endBefore) ref = ref.endBefore(endBefore);\n  return ref;\n}\n\nfunction whereToStr(where) {\n  return (0, _isString2.default)(where[0]) ? \"where=\".concat(where.join(':')) : where.map(whereToStr);\n}\n\nfunction getQueryName(meta) {\n  if ((0, _isString2.default)(meta)) {\n    return meta;\n  }\n\n  var collection = meta.collection,\n      doc = meta.doc,\n      subcollections = meta.subcollections,\n      where = meta.where,\n      limit = meta.limit;\n\n  if (!collection) {\n    throw new Error('Collection is required to build query name');\n  }\n\n  var basePath = collection;\n\n  if (doc) {\n    basePath = basePath.concat(\"/\".concat(doc));\n  }\n\n  if (subcollections) {\n    var mappedCollections = subcollections.map(function (subcollection) {\n      return getQueryName(subcollection);\n    });\n    basePath = \"\".concat(basePath, \"/\").concat(mappedCollections.join('/'));\n  }\n\n  if (where) {\n    if (!(0, _isArray2.default)(where)) {\n      throw new Error('where parameter must be an array.');\n    }\n\n    basePath = basePath.concat(\"?\".concat(whereToStr(where)));\n  }\n\n  if (typeof limit !== 'undefined') {\n    var limitStr = \"limit=\".concat(limit);\n    basePath = basePath.concat(\"\".concat(where ? '&' : '?').concat(limitStr));\n  }\n\n  return basePath;\n}\n\nfunction getBaseQueryName(meta) {\n  if ((0, _isString2.default)(meta)) {\n    return meta;\n  }\n\n  var collection = meta.collection,\n      subcollections = meta.subcollections,\n      where = meta.where,\n      limit = meta.limit;\n\n  if (!collection) {\n    throw new Error('Collection is required to build query name');\n  }\n\n  var basePath = collection;\n\n  if (subcollections) {\n    var mappedCollections = subcollections.map(function (subcollection) {\n      return getQueryName(subcollection);\n    });\n    basePath = \"\".concat(basePath, \"/\").concat(mappedCollections.join('/'));\n  }\n\n  if (where) {\n    if (!(0, _isArray2.default)(where)) {\n      throw new Error('where parameter must be an array.');\n    }\n\n    basePath = basePath.concat(\"?\".concat(whereToStr(where)));\n  }\n\n  if (typeof limit !== 'undefined') {\n    var limitStr = \"limit=\".concat(limit);\n    basePath = basePath.concat(\"\".concat(where ? '&' : '?').concat(limitStr));\n  }\n\n  return basePath;\n}\n\nfunction confirmMetaAndConfig(firebase, meta) {\n  if (!meta) {\n    throw new Error('Meta data is required to attach listener.');\n  }\n\n  if (!(0, _has2.default)(firebase, '_.listeners')) {\n    throw new Error('Internal Firebase object required to attach listener. Confirm that reduxFirestore enhancer was added when you were creating your store');\n  }\n}\n\nfunction listenerExists(firebase, meta) {\n  confirmMetaAndConfig(firebase, meta);\n  var name = getQueryName(meta);\n  return !!firebase._.listeners[name];\n}\n\nfunction attachListener(firebase, dispatch, meta, unsubscribe) {\n  confirmMetaAndConfig(firebase, meta);\n  var name = getQueryName(meta);\n\n  if (!firebase._.listeners[name]) {\n    firebase._.listeners[name] = unsubscribe;\n  }\n\n  dispatch({\n    type: _constants.actionTypes.SET_LISTENER,\n    meta: meta,\n    payload: {\n      name: name\n    }\n  });\n  return firebase._.listeners;\n}\n\nfunction detachListener(firebase, dispatch, meta) {\n  var name = getQueryName(meta);\n\n  if (firebase._.listeners[name]) {\n    firebase._.listeners[name]();\n\n    delete firebase._.listeners[name];\n  }\n\n  dispatch({\n    type: _constants.actionTypes.UNSET_LISTENER,\n    meta: meta,\n    payload: {\n      name: name\n    }\n  });\n}\n\nfunction queryStrToObj(queryPathStr, parsedPath) {\n  var pathArr = parsedPath || (0, _trim2.default)(queryPathStr, ['/']).split('/');\n\n  var _pathArr = (0, _toArray2.default)(pathArr),\n      collection = _pathArr[0],\n      doc = _pathArr[1],\n      subcollections = _pathArr.slice(2);\n\n  var queryObj = {};\n  if (collection) queryObj.collection = collection;\n  if (doc) queryObj.doc = doc;\n\n  if (subcollections.length) {\n    queryObj.subcollections = [queryStrToObj('', subcollections)];\n  }\n\n  return queryObj;\n}\n\nfunction getQueryConfig(query) {\n  if ((0, _isString2.default)(query)) {\n    return queryStrToObj(query);\n  }\n\n  if ((0, _isObject2.default)(query)) {\n    if (!query.collection && !query.doc) {\n      throw new Error('Collection and/or Doc are required parameters within query definition object.');\n    }\n\n    return query;\n  }\n\n  throw new Error('Invalid Path Definition: Only Strings and Objects are accepted.');\n}\n\nfunction getQueryConfigs(queries) {\n  if ((0, _isArray2.default)(queries)) {\n    return queries.map(getQueryConfig);\n  }\n\n  if ((0, _isString2.default)(queries)) {\n    return queryStrToObj(queries);\n  }\n\n  if ((0, _isObject2.default)(queries)) {\n    return [getQueryConfig(queries)];\n  }\n\n  throw new Error('Querie(s) must be an Array or a string.');\n}\n\nfunction orderedFromSnap(snap) {\n  var ordered = [];\n\n  if (snap.data && snap.exists) {\n    var obj = (0, _isObject2.default)(snap.data()) ? (0, _objectSpread2.default)({\n      id: snap.id\n    }, snap.data() || snap.data) : {\n      id: snap.id,\n      data: snap.data()\n    };\n    ordered.push(obj);\n  } else if (snap.forEach) {\n    snap.forEach(function (doc) {\n      var obj = (0, _isObject2.default)(doc.data()) ? (0, _objectSpread2.default)({\n        id: doc.id\n      }, doc.data() || doc.data) : {\n        id: doc.id,\n        data: doc.data()\n      };\n      ordered.push(obj);\n    });\n  }\n\n  return ordered;\n}\n\nfunction dataByIdSnapshot(snap) {\n  var data = {};\n\n  if (snap.data && snap.exists) {\n    data[snap.id] = snap.data();\n  } else if (snap.forEach) {\n    snap.forEach(function (doc) {\n      data[doc.id] = doc.data() || doc;\n    });\n  }\n\n  return (0, _size2.default)(data) ? data : null;\n}\n\nfunction getPopulateChild(firebase, populate, id) {\n  return firestoreRef(firebase, {\n    collection: populate.root,\n    doc: id\n  }).get().then(function (snap) {\n    return snap.data();\n  });\n}\n\nfunction populateList(firebase, list, p, results) {\n  if (!results[p.root]) {\n    (0, _set2.default)(results, p.root, {});\n  }\n\n  return Promise.all((0, _map2.default)(list, function (id, childKey) {\n    var populateKey = id === true || p.populateByKey ? childKey : id;\n    return getPopulateChild(firebase, p, populateKey).then(function (pc) {\n      if (pc) {\n        return (0, _set2.default)(results, \"\".concat(p.root, \".\").concat(populateKey), pc);\n      }\n\n      return results;\n    });\n  }));\n}\n\nfunction getPopulateObj(str) {\n  if (!(0, _isString2.default)(str)) {\n    return str;\n  }\n\n  var strArray = str.split(':');\n  return {\n    child: strArray[0],\n    root: strArray[1]\n  };\n}\n\nfunction getPopulateObjs(arr) {\n  if (!(0, _isArray2.default)(arr)) {\n    return arr;\n  }\n\n  return arr.map(function (o) {\n    return (0, _isObject2.default)(o) ? o : getPopulateObj(o);\n  });\n}\n\nfunction promisesForPopulate(firebase, dataKey, originalData, populatesIn) {\n  var promisesArray = [];\n  var results = {};\n  var populatesForData = getPopulateObjs((0, _isFunction2.default)(populatesIn) ? populatesIn(dataKey, originalData) : populatesIn);\n  var dataHasPopulateChilds = (0, _some2.default)(populatesForData, function (populate) {\n    return (0, _has2.default)(originalData, populate.child);\n  });\n\n  if (dataHasPopulateChilds) {\n    (0, _forEach2.default)(populatesForData, function (p) {\n      if ((0, _isString2.default)((0, _get2.default)(originalData, p.child))) {\n        return promisesArray.push(getPopulateChild(firebase, p, (0, _get2.default)(originalData, p.child)).then(function (v) {\n          if (v) {\n            (0, _set2.default)(results, \"\".concat(p.root, \".\").concat((0, _get2.default)(originalData, p.child)), v);\n          }\n        }));\n      }\n\n      return promisesArray.push(populateList(firebase, (0, _get2.default)(originalData, p.child), p, results));\n    });\n  } else {\n    (0, _forEach2.default)(originalData, function (d, key) {\n      var populatesForDataItem = getPopulateObj((0, _isFunction2.default)(populatesIn) ? populatesIn(key, d) : populatesIn);\n      (0, _forEach2.default)(populatesForDataItem, function (p) {\n        var idOrList = (0, _get2.default)(d, p.child);\n\n        if (!idOrList) {\n          return;\n        }\n\n        if ((0, _isString2.default)(idOrList)) {\n          return promisesArray.push(getPopulateChild(firebase, p, idOrList).then(function (v) {\n            if (v) {\n              (0, _set2.default)(results, \"\".concat(p.root, \".\").concat(idOrList), v);\n            }\n\n            return results;\n          }));\n        }\n\n        if ((0, _isArray2.default)(idOrList) || (0, _isObject2.default)(idOrList)) {\n          return promisesArray.push(populateList(firebase, idOrList, p, results));\n        }\n      });\n    });\n  }\n\n  return Promise.all(promisesArray).then(function () {\n    return results;\n  });\n}\n\nvar changeTypeToEventType = {\n  added: _constants.actionTypes.DOCUMENT_ADDED,\n  removed: _constants.actionTypes.DOCUMENT_REMOVED,\n  modified: _constants.actionTypes.DOCUMENT_MODIFIED\n};\n\nfunction docChangeEvent(change) {\n  var originalMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var meta = (0, _objectSpread2.default)({}, originalMeta, {\n    path: change.doc.ref.path\n  });\n\n  if (originalMeta.subcollections && !originalMeta.storeAs) {\n    meta.subcollections[0] = (0, _objectSpread2.default)({}, meta.subcollections[0], {\n      doc: change.doc.id\n    });\n  } else {\n    meta.doc = change.doc.id;\n  }\n\n  return {\n    type: changeTypeToEventType[change.type] || _constants.actionTypes.DOCUMENT_MODIFIED,\n    meta: meta,\n    payload: {\n      data: change.doc.data(),\n      ordered: {\n        oldIndex: change.oldIndex,\n        newIndex: change.newIndex\n      }\n    }\n  };\n}\n\nfunction dispatchListenerResponse(_ref) {\n  var dispatch = _ref.dispatch,\n      docData = _ref.docData,\n      meta = _ref.meta,\n      firebase = _ref.firebase;\n\n  var _ref2 = firebase._.config || {},\n      mergeOrdered = _ref2.mergeOrdered,\n      mergeOrderedDocUpdates = _ref2.mergeOrderedDocUpdates,\n      mergeOrderedCollectionUpdates = _ref2.mergeOrderedCollectionUpdates;\n\n  var docChanges = typeof docData.docChanges === 'function' ? docData.docChanges() : docData.docChanges;\n\n  if (docChanges && docChanges.length < docData.size) {\n    docChanges.forEach(function (change) {\n      dispatch(docChangeEvent(change, meta));\n    });\n  } else {\n    dispatch({\n      type: _constants.actionTypes.LISTENER_RESPONSE,\n      meta: meta,\n      payload: {\n        data: dataByIdSnapshot(docData),\n        ordered: orderedFromSnap(docData)\n      },\n      merge: {\n        docs: mergeOrdered && mergeOrderedDocUpdates,\n        collections: mergeOrdered && mergeOrderedCollectionUpdates\n      }\n    });\n  }\n}\n\nfunction getPopulateActions(_x) {\n  return _getPopulateActions.apply(this, arguments);\n}\n\nfunction _getPopulateActions() {\n  _getPopulateActions = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref3) {\n    var firebase, docData, meta, _ref4, _ref5, populateErr, populateResults;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            firebase = _ref3.firebase, docData = _ref3.docData, meta = _ref3.meta;\n            _context.next = 3;\n            return (0, _async.to)(promisesForPopulate(firebase, docData.id, dataByIdSnapshot(docData), meta.populates));\n\n          case 3:\n            _ref4 = _context.sent;\n            _ref5 = (0, _slicedToArray2.default)(_ref4, 2);\n            populateErr = _ref5[0];\n            populateResults = _ref5[1];\n\n            if (!populateErr) {\n              _context.next = 10;\n              break;\n            }\n\n            console.error('Error with populate:', populateErr, meta);\n            throw populateErr;\n\n          case 10:\n            return _context.abrupt(\"return\", Object.keys(populateResults).map(function (resultKey) {\n              return {\n                meta: {\n                  collection: resultKey\n                },\n                payload: {\n                  data: populateResults[resultKey]\n                },\n                requesting: false,\n                requested: true\n              };\n            }));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  return _getPopulateActions.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}